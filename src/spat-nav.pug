spat-nav
  div.spat-pages(ref='pages')
  div.spat-lock(show='{_locked}', ref='lock')

  style(scoped, type='less').
    :scope {
      position: relative;
      display: block;
      width: 100%;
      height: 100%;

      .spat-pages {
        position: absolute;
        width: 100%;
        height: 100%;

        .spat-page {
          position: absolute;
          width: 100%;
          height: 100%;
          backface-visibility: hidden;
          animation-fill-mode: forwards;
          overflow: scroll;
          -webkit-overflow-scrolling: touch;
          overflow-scrolling: touch;

          &.spat-hide {
            display: none;
          }
        }
      }

      .spat-lock {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        z-index: 9999;
        background-color: transparent;
      }
    }
    @keyframes slide-in {
      0% { transform: translate(250px, 0px); opacity: 0; }
      100% { transform: translate(0px, 0px); opacity: 1; }
    }
    @keyframes slide-out {
      0% { opacity: 1; }
      100% { opacity: 0.8; }
    }

    @keyframes scale-in {
      0% { transform: scale(0.5); opacity: 0; }
      0% { transform: scale(0.5); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    @keyframes scale-out {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0; }
      100% { transform: scale(1.5); opacity: 0; }
    }

    @keyframes rotate-in {
      0% { transform: perspective(800px) rotateY(180deg); opacity: 0; }
      100% { transform: perspective(800px) rotateY(0deg); opacity: 1; }
    }
    @keyframes rotate-out {
      0% { transform: perspective(800px) rotateY(0deg); opacity: 1; }
      100% { transform: perspective(800px) rotateY(-180deg); opacity: 0; }
    }

  script.
    var self = this;

    this.animation = '';
    this.animationDuration = '256ms';
    this._back = false;
    this._locked = false;
    this._autoRender = true;

    this.lock = function(color) {
      this._locked = true;
      this.update();
      if (color) {
        this.refs.lock.style.backgroundColor = color;
      }
    };

    this.unlock = function() {
      this._locked = false;
      this.refs.lock.style.backgroundColor = '';
      this.update();
    };

    this.swap = function(tagName, opts) {
      var prevPage = this.currentPage;

      // 現在の url を page id としてキャッシュ判定する
      var pageId = location.href.replace(location.origin, '');
      // マウント済みのページを取得
      var page = this.refs.pages.querySelector('[data-page-id="' + pageId + '"]');
      // キャッシュフラグ
      var cached = false;

      // まだマウントされていなければ新たにマウントする
      if(page === null) {
        page = document.createElement('div');
        page.classList.add('spat-page');
        page.classList.add('spat-hide');
        page.setAttribute('data-page-id', pageId);
        this.refs.pages.appendChild(page);
        riot.mount(page, tagName);
      }
      else {
        cached = true;
        if (!this._back) {
          // 最前面に移動
          var parent = page.parentNode;
          parent.removeChild(page);
          parent.appendChild(page);
        }
      };

      // 画面をロック
      this.lock();

      // イベントオブジェクトを作成
      var d = Date.now();
      var e = {
        prevPage: prevPage,
        currentPage: page,
        query: this.query(),
        args: Array.prototype.slice.call(arguments),
        //- opts: spat.nav.opts || {},
        opts: opts || {},
        back: self._back,
        cached: cached,
        render: function() {
          if (!self._autoRender) {
            self._swap(page, prevPage);
            console.log(Date.now() - d);
          }
        },
      };
      page._tag.trigger('show', e);

      if (this._autoRender) {
        this._swap(page, prevPage);
      }
    };

    this._swap = function(page, prevPage) {

      page.classList.remove('spat-hide');

      // swap animation
      swapAnimation(page, prevPage, this._back).then(function() {
        // 前のページがあった場合
        if (prevPage) {
          prevPage.classList.add('spat-hide');
        }

        self.unlock();
      });

      self._back = false;

      this.currentPage = page;
      this.prevPage = prevPage;

      delete spat.nav.opts;
    };

    this.back = function(index, opts) {
      self._back = true;

      if (typeof index === 'number') {
        history.go(-index);
      }
      else {
        history.back();
      }
    };

    this.query = function() {
      var q = {};
      location.search.replace(/[?&](.+?)=([^&]*)/g, function(m, key, value) { q[key] = value; });
      return q;
    };

    this.clearCache = function() {
      this.currentPage = null;
      this.prevPage = null;
      this.refs.pages.innerHTML = '';

      return this;
    };

    window.spat.nav = this;

    /*
     * for dom
     */
    var swapAnimation = function(next, prev, back) {
      var animation = (back !== true) ? next.getAttribute('spat-animation') : prev.getAttribute('spat-animation');
      animation = animation || self.animation;
      
      self.animationDuration = (back !== true) ? next.getAttribute('animation-duration') : prev.getAttribute('animation-duration');

      if (!animation) {
        return Promise.resolve();
      }

      if (!back) {
        var direction = '';
        var nextAnimation = animation + '-in';
        var prevAnimation = animation + '-out'
      }
      else {
        var direction = 'reverse';
        var nextAnimation = animation + '-out';
        var prevAnimation = animation + '-in'
      }
      var duration = self.animationDuration ? self.animationDuration + 'ms' : '256ms';

      return new Promise(function(resolve) {
        // 今のページをアニメーション
        setAnimation(next, nextAnimation, duration, direction);
        onceEvent(next, 'animationend', function() {
          setAnimation(next);
          resolve();
        });

        if (prev) {
          setAnimation(prev, prevAnimation, duration, direction);
          onceEvent(prev, 'animationend', function() {
            setAnimation(prev);
          });
        }
      });
    };
    var setAnimation = function(elm, name, duration, direction) {
      elm.style.animationDuration = duration || '';
      elm.style.animationDirection = direction || '';
      elm.style.animationName = name || '';
    };
    var onceEvent = function(elm, evtName, fn) {
      var temp = function() {
        elm.removeEventListener(evtName, temp, false);
        fn();
      };
      elm.addEventListener(evtName, temp, false);
    };


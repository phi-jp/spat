spat-nav
  div.spat-pages(ref='pages', onmousedown='{swipestart}', onmousemove='{swipe}', onmouseup='{swipeend}', ontouchstart='{swipestart}', ontouchmove='{swipe}', ontouchend='{swipeend}')
  div.spat-lock(show='{_locked}', ref='lock', onmousemove='{swipe}', onmouseup='{swipeend}', ontouchmove='{swipe}', ontouchend='{swipeend}')

  style(scoped, type='less').
    :scope {
      position: relative;
      display: block;
      width: 100%;
      height: 100%;

      .spat-pages {
        position: absolute;
        width: 100%;
        height: 100%;

        .spat-page {
          position: absolute;
          width: 100%;
          height: 100%;
          backface-visibility: hidden;
          animation-fill-mode: forwards;
          overflow: scroll;
          -webkit-overflow-scrolling: touch;
          overflow-scrolling: touch;

          &.spat-hide {
            display: none;
          }
        }
      }

      .spat-lock {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        z-index: 9999;
        background-color: transparent;
      }
    }
    @keyframes slide-in {
      0% { transform: translate(250px, 0px); opacity: 0; }
      100% { transform: translate(0px, 0px); opacity: 1; }
    }
    @keyframes slide-out {
      0% { opacity: 1; }
      100% { opacity: 0.8; }
    }

    @keyframes scale-in {
      0% { transform: scale(0.5); opacity: 0; }
      0% { transform: scale(0.5); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    @keyframes scale-out {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0; }
      100% { transform: scale(1.5); opacity: 0; }
    }

    @keyframes rotate-in {
      0% { transform: perspective(800px) rotateY(180deg); opacity: 0; -webkit-backface-visibility:initial !important; }
      100% { transform: perspective(800px) rotateY(0deg); opacity: 1; -webkit-backface-visibility:initial !important; }
    }
    @keyframes rotate-out {
      0% { transform: perspective(800px) rotateY(0deg); opacity: 1; -webkit-backface-visibility:initial !important; }
      100% { transform: perspective(800px) rotateY(-180deg); opacity: 0; -webkit-backface-visibility:initial !important; }
    }

    @keyframes pushed-in {
      0% { transform: translate(0px, 50vh); opacity: 0; }
      100% { transform: translate(0px, 0px); opacity: 1; }
    }
    @keyframes pushed-out {
      0% { opacity: 1; }
      100% { opacity: 0.8; }
    }


  script.
    var self = this;

    this.animation = '';
    this.animationDuration = '256ms';
    this._back = false;
    this._locked = false;
    this._autoRender = true;
    this.edgeSwipeWidth = 30;

    this.on('mount', function() {
      var pages = self.refs.pages;
    });

    this.lock = function(color) {
      this._locked = true;
      this.update();
      if (color) {
        this.refs.lock.style.backgroundColor = color;
      }
    };

    this.unlock = function() {
      this._locked = false;
      this.refs.lock.style.backgroundColor = '';
      this.update();
    };

    this.swap = function(tagName, opts) {
      var prevPage = this.currentPage;

      // 現在の url を page id としてキャッシュ判定する
      var pageId = location.href.replace(location.origin, '');
      // マウント済みのページを取得
      var page = this.refs.pages.querySelector('[data-page-id="' + pageId + '"]');
      // キャッシュフラグ
      var cached = false;

      // まだマウントされていなければ新たにマウントする
      if(page === null) {
        page = document.createElement('div');
        page.classList.add('spat-page');
        page.classList.add('spat-hide');
        page.setAttribute('data-page-id', pageId);
        this.refs.pages.appendChild(page);
        riot.mount(page, tagName);
      }
      else {
        cached = true;
        if (!this._back) {
          // 最前面に移動
          var parent = page.parentNode;
          parent.removeChild(page);
          parent.appendChild(page);
        }
      };

      // 画面をロック
      this.lock();

      // イベントオブジェクトを作成
      var d = Date.now();
      var e = {
        prevPage: prevPage,
        currentPage: page,
        query: this.query(),
        args: Array.prototype.slice.call(arguments),
        //- opts: spat.nav.opts || {},
        opts: opts || {},
        back: self._back,
        cached: cached,
        render: function() {
          if (!self._autoRender) {
            self._swap(page, prevPage);
            console.log(Date.now() - d);
          }
        },
      };
      page._tag.trigger('show', e);
      page._tag.update();

      if (prevPage) {
        prevPage._tag.trigger('hide', e);
        prevPage._tag.update();
      }

      this.trigger('swap', {
      });

      if (this._autoRender) {
        this._swap(page, prevPage);
      }
    };

    this._swap = function(page, prevPage) {

      page.classList.remove('spat-hide');

      // swap animation
      swapAnimation(page, prevPage, this._back).then(function() {
        // 現在のページ以外を非表示にする
        Array.prototype.forEach.call(self.refs.pages.children, function(page) {
          if (page !== self.currentPage) page.classList.add('spat-hide');
        });

        self.unlock();
      });

      self._back = false;

      this.currentPage = page;
      this.prevPage = prevPage;

      delete spat.nav.opts;
    };

    this.back = function(index, opts) {
      self._back = true;

      if (typeof index === 'number') {
        history.go(-index);
      }
      else {
        history.back();
      }
    };

    this.query = function() {
      var q = {};
      location.search.replace(/[?&](.+?)=([^&]*)/g, function(m, key, value) { q[key] = value; });
      return q;
    };

    this.clearCache = function() {
      this.currentPage = null;
      this.prevPage = null;
      this.refs.pages.innerHTML = '';

      return this;
    };

    this.updateCache = function() {
      if (this.currentPage) {
        var pageId = location.href.replace(location.origin, '');
        this.currentPage.setAttribute('data-page-id', pageId);
      }
      return this;
    };

    this.swipestart = function(e) {
      e.preventUpdate = true;
      if (!self.prevPage) {
        return ;
      }
      var p = self.toPoint(e);
      if (p.clientX < self.edgeSwipeWidth) {
        self._holdSwipe = true;
        self.x = self.sx = self.px = p.clientX;
        self.y = self.sy = self.py = p.clientY;
      }
    };

    this.swipe = function(e) {
      e.preventUpdate = true;
      if (!self._holdSwipe) {
        return ;
      }
      var p = self.toPoint(e);
      self.mx = p.clientX - self.px;
      self.my = p.clientY - self.py;
      self.px = self.x;
      self.py = self.y;
      self.x = p.clientX;
      self.y = p.clientY;
      self.dx = self.x - self.sx;
      self.dy = self.y - self.sy;
      if (self._edgeSwipe) {
        e.preventDefault();
        e.stopPropagation();
        self.updatePageSwipe();
        return ;
      }
      var ax = Math.abs(self.dx);
      var ay = Math.abs(self.dy);
      if (ax === ay) {
        return ;
      }
      if (ax > ay) {
        e.preventDefault();
        self._edgeSwipe = true;
        self.startPageSwipe();
      }
      else {
        self._holdSwipe = false;
      }
      
    };

    this.swipeend = function(e) {
      e.preventUpdate = true;
      self.currentFinger = null;
      if (!self._holdSwipe) {
        return ;
      }
      self._holdSwipe = false;
      self._edgeSwipe = false;
      self.lock();
      e.preventDefault();
      e.stopPropagation();
      var page = self.currentPage;
      var style = page.style;
      style.transition = self.animationDuration || '256ms';
      var back = self.checkSwipeBack();
      // 少しでも数値が変わらないと transitionend が発火しないので -0.1 にしている
      var x = back ? '100%' : '-0.1px';
      style.transform = 'translateX(' + x + ')';
      if (back) {
        style.opacity = '0';
      }
      onceEvent(page, 'transitionend', function() {
        if (back) {
          page.classList.add('spat-hide');
          // TODO: うまくやる
          spat.nav.back();
        }
        else {
          self.prevPage.classList.add('spat-hide');
        }
        style.removeProperty('opacity');
        style.removeProperty('transform');
        style.removeProperty('transition');
        style.removeProperty('box-shadow');
        
        self.unlock();
      });
    };

    this.startPageSwipe = function() {
      self.currentPage.style.boxShadow = '0 0 100vw -1px rgba(0, 0, 0, 0.5)';
      self.currentPage.style.opacity = '1';
      self.prevPage.classList.remove('spat-hide');
      self.lock();
    };

    this.updatePageSwipe = function() {
      self.currentPage.style.transform = 'translateX(' + Math.max(self.dx, 0) + 'px)';
    };

    this.checkSwipeBack = function() {
      var SWIPE_WIDTH_THRESHOLD = 0.5;
      var SWIPE_SPEED_THRESHOLD = 10;
      var rate = self.dx / (innerWidth * SWIPE_WIDTH_THRESHOLD);
      rate += self.mx / SWIPE_SPEED_THRESHOLD;
      return rate > 1;
    };

    this.toPoint = function(e) {
      var touches = e.changedTouches;
      // SP
      if (touches) {
        if (!self.currentFinger) {
          return self.currentFinger = touches[0];
        }
        else {
          return Array.prototype.find.call(touches, function(touch) {
            return touch.identifier === self.currentFinger.identifier;
          });
        }
      }
      // PC
      else {
        return e;
      }
    };

    window.spat.nav = this;

    /*
     * for dom
     */
    var swapAnimation = function(next, prev, back) {
      var animation = (back !== true) ? next.getAttribute('spat-animation') : prev.getAttribute('spat-animation');
      animation = animation || self.animation;
      
      self.animationDuration = (back !== true) ? next.getAttribute('animation-duration') : prev.getAttribute('animation-duration');

      if (!animation) {
        return Promise.resolve();
      }

      if (!back) {
        var direction = '';
        var nextAnimation = animation + '-in';
        var prevAnimation = animation + '-out'
      }
      else {
        var direction = 'reverse';
        var nextAnimation = animation + '-out';
        var prevAnimation = animation + '-in'
      }
      var duration = self.animationDuration ? self.animationDuration + 'ms' : '256ms';

      return new Promise(function(resolve) {
        // 今のページをアニメーション
        setAnimation(next, nextAnimation, duration, direction);
        onceEvent(next, 'animationend', function() {
          setAnimation(next);
          resolve();
        });

        if (prev) {
          setAnimation(prev, prevAnimation, duration, direction);
          onceEvent(prev, 'animationend', function() {
            setAnimation(prev);
          });
        }
      });
    };
    var setAnimation = function(elm, name, duration, direction) {
      elm.style.animationDuration = duration || '';
      elm.style.animationDirection = direction || '';
      elm.style.animationName = name || '';
    };
    var onceEvent = function(elm, evtName, fn) {
      var temp = function() {
        elm.removeEventListener(evtName, temp, false);
        fn();
      };
      elm.addEventListener(evtName, temp, false);
    };


spat-nav
  div.spat-pages(ref='pages', onmousedown='{_swipestart}', onmousemove='{_swipe}', onmouseup='{_swipeend}', ontouchstart='{_swipestart}', ontouchmove='{_swipe}', ontouchend='{_swipeend}', ondragend='{_swipeend}')
  div.spat-lock(show='{_locked}', ref='lock', onmousemove='{_swipe}', onmouseup='{_swipeend}')

  style(scoped, type='less').
    :scope {
      position: relative;
      display: block;
      width: 100%;
      height: 100%;

      .spat-pages {
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: 0;

        .spat-page {
          position: absolute;
          z-index: 0;
          width: 100%;
          height: 100%;
          backface-visibility: hidden;
          animation-fill-mode: forwards;
          overflow: scroll;
          -webkit-overflow-scrolling: touch;
          overflow-scrolling: touch;
          &.current {
            z-index: 9999;
          }
          &.spat-hide {
            display: none;
          }
        }
      }

      .spat-lock {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        z-index: 9999;
        background-color: transparent;
      }
    }
    @keyframes slide-in {
      0% { transform: translate(250px, 0px); opacity: 0; }
      100% { transform: translate(0px, 0px); opacity: 1; }
    }
    @keyframes slide-out {
      0% { opacity: 1; }
      100% { opacity: 0.8; }
    }

    @keyframes scale-in {
      0% { transform: scale(0.5); opacity: 0; }
      0% { transform: scale(0.5); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    @keyframes scale-out {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0; }
      100% { transform: scale(1.5); opacity: 0; }
    }

    @keyframes rotate-in {
      0% { transform: perspective(800px) rotateY(180deg); opacity: 0; -webkit-backface-visibility:initial !important; }
      100% { transform: perspective(800px) rotateY(0deg); opacity: 1; -webkit-backface-visibility:initial !important; }
    }
    @keyframes rotate-out {
      0% { transform: perspective(800px) rotateY(0deg); opacity: 1; -webkit-backface-visibility:initial !important; }
      100% { transform: perspective(800px) rotateY(-180deg); opacity: 0; -webkit-backface-visibility:initial !important; }
    }

    @keyframes pushed-in {
      0% { transform: translate(0px, 50vh); opacity: 0; }
      100% { transform: translate(0px, 0px); opacity: 1; }
    }
    @keyframes pushed-out {
      0% { opacity: 1; }
      100% { opacity: 0.8; }
    }


  script.
    var self = this;

    this.animation = '';
    this.animationDuration = '256ms';
    this._back = false;
    this._locked = false;
    this._autoRender = true;
    // 画面端からスワイプが反応する幅の割合
    this.swipeWidthRate = 1;
    // スワイプでページが動き始めるために必要な幅(px)
    this.swipeThreshold = 1;

    this.on('mount', function() {
      var pages = self.refs.pages;
    });

    this.lock = function(color) {
      this._locked = true;
      this.update();
      if (color) {
        this.refs.lock.style.backgroundColor = color;
      }
    };

    this.unlock = function() {
      this._locked = false;
      this.refs.lock.style.backgroundColor = '';
      this.update();
    };

    this.getPage = function(pageId) {
      return self.refs.pages.querySelector('[data-page-id="' + pageId + '"]');
    };

    this.swap = function(tagName, opts) {
      var prevPage = this.currentPage;

      // 現在の url を page id としてキャッシュ判定する
      var pageId = location.href.replace(location.origin, '');
      // マウント済みのページを取得
      var page = self.getPage(pageId);
      // キャッシュフラグ
      var cached = false;
      
      // まだマウントされていなければ新たにマウントする
      if(page === null) {
        page = document.createElement('div');
        page.classList.add('spat-page');
        page.classList.add('spat-hide');
        page.setAttribute('data-page-id', pageId);
        this.refs.pages.appendChild(page);
        riot.mount(page, tagName);
      }
      else {
        cached = true;
        if (!this._back) {
          // 最前面に移動
          var parent = page.parentNode;
          parent.removeChild(page);
          parent.appendChild(page);
        }
      };

      // 画面をロック
      this.lock();

      // イベントオブジェクトを作成
      var d = Date.now();
      var e = {
        prevPage: prevPage,
        currentPage: page,
        query: this.query(),
        args: Array.prototype.slice.call(arguments),
        //- opts: spat.nav.opts || {},
        opts: opts || {},
        back: self._back,
        cached: cached,
        render: function() {
          if (!self._autoRender) {
            self._swap(page, prevPage);
            console.log(Date.now() - d);
          }
        },
      };
      delete page.dataset.canBack;
      delete page.dataset.canForward;
      delete page.dataset.backId;
      delete page.dataset.nextId;
      this.trigger('swap', e);
      page._tag.trigger('show', e);
      page._tag.update();

      if (prevPage) {
        prevPage._tag.trigger('hide', e);
        prevPage._tag.update();
      }

      if (this._autoRender) {
        this._swap(page, prevPage);
      }
    };

    // ページをスワイプしたい場合に設定する
    this.setupPageSwipe = function(page, data) {
      data = data || {};
      if (data.canBack) {
        page.dataset.canBack = 'true';
      }
      if (data.canForward) {
        page.dataset.canForward = 'true';
      }
      page.dataset.backId = data.backId;
      page.dataset.nextId = data.nextId;
      return this;
    };

    this._swap = function(page, prevPage) {

      page.classList.remove('spat-hide');

      // swap animation
      var swapPromise = self.disableSwapAnimation ? Promise.resolve() : swapAnimation(page, prevPage, this._back);
      
      swapPromise.then(function() {
        // 現在のページ以外を非表示にする
        Array.prototype.forEach.call(self.refs.pages.children, function(page) {
          if (page !== self.currentPage) {
            page.classList.add('spat-hide');
            page.classList.remove('current');
          }
        });

        // 最前面に移動
        page.classList.add('current');

        self.unlock();
      });

      self._back = false;
      self.disableSwapAnimation = false;

      this.currentPage = page;
      this.prevPage = prevPage;

      delete spat.nav.opts;
    };

    this.back = function(index, opts) {
      self._back = true;

      if (typeof index === 'number') {
        history.go(-index);
      }
      else {
        history.back();
      }
    };

    this.query = function() {
      var q = {};
      location.search.replace(/[?&](.+?)=([^&]*)/g, function(m, key, value) { q[key] = value; });
      return q;
    };

    this.clearCache = function() {
      this.currentPage = null;
      this.prevPage = null;
      this.refs.pages.innerHTML = '';

      return this;
    };

    this.updateCache = function() {
      if (this.currentPage) {
        var pageId = location.href.replace(location.origin, '');
        this.currentPage.setAttribute('data-page-id', pageId);
      }
      return this;
    };

    this._swipestart = function(e) {
      e.preventUpdate = true;
      if (self._locked || !self.currentPage.dataset.canBack || e.defaultPrevented) {
        self.cancelSwipe();
        return ;
      }
      var p = self.toPoint(e);
      if (p.clientX < innerWidth * self.swipeWidthRate) {
        self._holdSwipe = true;
        self.x = self.sx = self.px = p.clientX;
        self.y = self.sy = self.py = p.clientY;
        self.mx = self.my = self.dx = self.dy = 0;
      }
    };

    this._swipe = function(e) {
      e.preventUpdate = true;
      if (!self._holdSwipe || e.defaultPrevented) {
        self.cancelSwipe();
        return ;
      }
      var p = self.toPoint(e);
      self.mx = p.clientX - self.px;
      self.my = p.clientY - self.py;
      self.px = self.x;
      self.py = self.y;
      self.x = p.clientX;
      self.y = p.clientY;
      self.dx = self.x - self.sx;
      self.dy = self.y - self.sy;
      if (self._swiping) {
        // 動かしているページの座標を更新する
        if (self._swipeAnimation) {
          e.preventDefault();
          e.stopPropagation();
          self._updatePageSwipe();
          return ;
        }
        // スワイプ中に一定以上スワイプしたら、ページ自体を transform で動くようにする
        if (self.dx > self.swipeThreshold) {
          e.preventDefault();
          e.stopPropagation();
          self._startPageSwipe();
        }
        return ;
      }
      var ax = Math.abs(self.dx);
      var ay = Math.abs(self.dy);
      if (ax === ay) {
        return ;
      }
      // 横移動が多かったら、スワイプしていることにする
      if (ax > ay) {
        e.preventDefault();
        e.stopPropagation();
        self._swiping = true;
      }
      else {
        self._holdSwipe = false;
      }
      
    };

    // スワイプしてない状態にする。 _releaseSwipe をしないといけない場合に true を返す
    this._resetSwipe = function() {
      self.currentFinger = null;
      if (!self._holdSwipe || !self._swipeAnimation) {
        self._swipeAnimation = false;
        self._holdSwipe = false;
        self._swiping = false;
        if (self._locked) {
          self.unlock();
        }
        return ;
      }
      return true;
    };

    this._releaseSwipe = function(back) {
      if (back === undefined) {
        back = self._checkSwipeBack();
      }
      self._swipeAnimation = false;
      self._holdSwipe = false;
      self._swiping = false;
      var page = self._swipePage;
      self._swipePage = null;
      var style = page.style;
      style.transition = '256ms';
      // 少しでも数値が変わらないと transitionend が発火しないので -0.1 にしている
      var x = back ? '100%' : '-0.1px';
      style.transform = 'translateX(' + x + ')';
      if (back) {
        style.opacity = '0';
      }
      onceEvent(page, 'transitionend', function() {
        if (back) {
          page.classList.add('spat-hide');
          self.disableSwapAnimation = true;
          self.trigger('swipebackend');
        }
        else {
          var backPage = self.getPage(page.dataset.backId);
          if (backPage && self.currentPage !== backPage) {
            backPage.classList.add('spat-hide');
          }
        }
        style.removeProperty('opacity');
        style.removeProperty('transform');
        style.removeProperty('transition');
        style.removeProperty('box-shadow');
        
        self.unlock();
      });
    };

    this._swipeend = function(e) {
      e.preventUpdate = true;
      if (self._resetSwipe()) {
        e.preventDefault();
        e.stopPropagation();
        self._releaseSwipe();
      }
    };
    
    // スワイプ中にブラウザバックした場合などにスワイプをキャンセルする
    this.cancelSwipe = function() {
      if (self._resetSwipe()) {
        self._releaseSwipe(false);
      }
    };

    this._startPageSwipe = function() {
      self.trigger('swipebackstart');
      self._swipeAnimation = true;
      var page = self._swipePage = self.currentPage;
      var style = page.style;
      style.boxShadow = '0 0 100vw -1px rgba(0, 0, 0, 0.5)';
      style.opacity = '1';
      var backPage = self.getPage(page.dataset.backId);
      if (backPage) {
        backPage.classList.remove('spat-hide');
      }
      self.lock();
    };

    this._updatePageSwipe = function() {
      self._swipePage.style.transform = 'translateX(' + Math.max(self.dx, 0) + 'px)';
    };

    this._checkSwipeBack = function() {
      var SWIPE_WIDTH_THRESHOLD = 0.5;
      var SWIPE_SPEED_THRESHOLD = 10;
      var rate = self.dx / (innerWidth * SWIPE_WIDTH_THRESHOLD);
      rate += self.mx / SWIPE_SPEED_THRESHOLD;
      return rate > 1;
    };

    this.toPoint = function(e) {
      var touches = e.changedTouches;
      // SP
      if (touches) {
        if (!self.currentFinger) {
          return self.currentFinger = touches[0];
        }
        else {
          return Array.prototype.find.call(touches, function(touch) {
            return touch.identifier === self.currentFinger.identifier;
          });
        }
      }
      // PC
      else {
        return e;
      }
    };

    window.spat.nav = this;

    /*
     * for dom
     */
    var swapAnimation = function(next, prev, back) {
      var animation = (back !== true) ? next.getAttribute('spat-animation') : prev.getAttribute('spat-animation');
      animation = animation || self.animation;
      
      self.animationDuration = (back !== true) ? next.getAttribute('animation-duration') : prev.getAttribute('animation-duration');

      if (!animation) {
        return Promise.resolve();
      }

      if (!back) {
        var direction = '';
        var nextAnimation = animation + '-in';
        var prevAnimation = animation + '-out'
      }
      else {
        var direction = 'reverse';
        var nextAnimation = animation + '-out';
        var prevAnimation = animation + '-in'
      }
      var duration = self.animationDuration ? self.animationDuration + 'ms' : '256ms';

      return new Promise(function(resolve) {
        // 今のページをアニメーション
        setAnimation(next, nextAnimation, duration, direction);
        onceEvent(next, 'animationend', function() {
          setAnimation(next);
          resolve();
        });

        if (prev) {
          setAnimation(prev, prevAnimation, duration, direction);
          onceEvent(prev, 'animationend', function() {
            setAnimation(prev);
          });
        }
      });
    };
    var setAnimation = function(elm, name, duration, direction) {
      elm.style.animationDuration = duration || '';
      elm.style.animationDirection = direction || '';
      elm.style.animationName = name || '';
    };
    var onceEvent = function(elm, evtName, fn) {
      var temp = function() {
        elm.removeEventListener(evtName, temp, false);
        fn();
      };
      elm.addEventListener(evtName, temp, false);
    };

